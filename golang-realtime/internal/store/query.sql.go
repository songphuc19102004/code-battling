// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addRoomPlayerScore = `-- name: AddRoomPlayerScore :one
UPDATE room_players
SET score = score + $3
WHERE room_id = $1 AND player_id = $2
RETURNING room_id, player_id, score, place, state
`

type AddRoomPlayerScoreParams struct {
	RoomID      int32
	PlayerID    int32
	ScoreTooAdd pgtype.Int4
}

func (q *Queries) AddRoomPlayerScore(ctx context.Context, arg AddRoomPlayerScoreParams) (RoomPlayer, error) {
	row := q.db.QueryRow(ctx, addRoomPlayerScore, arg.RoomID, arg.PlayerID, arg.ScoreTooAdd)
	var i RoomPlayer
	err := row.Scan(
		&i.RoomID,
		&i.PlayerID,
		&i.Score,
		&i.Place,
		&i.State,
	)
	return i, err
}

const createLanguage = `-- name: CreateLanguage :one
INSERT INTO languages (id, name, compile_cmd, run_cmd, timeout_second)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, compile_cmd, run_cmd, timeout_second
`

type CreateLanguageParams struct {
	ID            int32
	Name          string
	CompileCmd    pgtype.Text
	RunCmd        pgtype.Text
	TimeoutSecond pgtype.Float8
}

// Languages
func (q *Queries) CreateLanguage(ctx context.Context, arg CreateLanguageParams) (Language, error) {
	row := q.db.QueryRow(ctx, createLanguage,
		arg.ID,
		arg.Name,
		arg.CompileCmd,
		arg.RunCmd,
		arg.TimeoutSecond,
	)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CompileCmd,
		&i.RunCmd,
		&i.TimeoutSecond,
	)
	return i, err
}

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO players (id, name, password)
VALUES ($1, $2, $3)
RETURNING id, name, password
`

type CreatePlayerParams struct {
	ID       int32
	Name     string
	Password string
}

// Players
func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, createPlayer, arg.ID, arg.Name, arg.Password)
	var i Player
	err := row.Scan(&i.ID, &i.Name, &i.Password)
	return i, err
}

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO questions (id, language_id, template_function, title, description, score, difficulty)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, language_id, template_function, title, description, score, difficulty
`

type CreateQuestionParams struct {
	ID               int32
	LanguageID       int32
	TemplateFunction pgtype.Text
	Title            string
	Description      pgtype.Text
	Score            int32
	Difficulty       int32
}

// Questions
func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.ID,
		arg.LanguageID,
		arg.TemplateFunction,
		arg.Title,
		arg.Description,
		arg.Score,
		arg.Difficulty,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.LanguageID,
		&i.TemplateFunction,
		&i.Title,
		&i.Description,
		&i.Score,
		&i.Difficulty,
	)
	return i, err
}

const createRoom = `-- name: CreateRoom :one
INSERT INTO rooms (id, name, description)
VALUES ($1, $2, $3)
RETURNING id, name, description
`

type CreateRoomParams struct {
	ID          int32
	Name        string
	Description pgtype.Text
}

// Rooms
func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (Room, error) {
	row := q.db.QueryRow(ctx, createRoom, arg.ID, arg.Name, arg.Description)
	var i Room
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const createRoomPlayer = `-- name: CreateRoomPlayer :one
INSERT INTO room_players (room_id, player_id, score, place)
VALUES ($1, $2, $3, $4)
RETURNING room_id, player_id, score, place, state
`

type CreateRoomPlayerParams struct {
	RoomID   int32
	PlayerID int32
	Score    pgtype.Int4
	Place    pgtype.Int4
}

// Room Players
func (q *Queries) CreateRoomPlayer(ctx context.Context, arg CreateRoomPlayerParams) (RoomPlayer, error) {
	row := q.db.QueryRow(ctx, createRoomPlayer,
		arg.RoomID,
		arg.PlayerID,
		arg.Score,
		arg.Place,
	)
	var i RoomPlayer
	err := row.Scan(
		&i.RoomID,
		&i.PlayerID,
		&i.Score,
		&i.Place,
		&i.State,
	)
	return i, err
}

const createSubmission = `-- name: CreateSubmission :one
INSERT INTO submissions (source_code, language_id, stdin, expected_output, stdout, status_id, created_at, finished_at, time, memory, stderr, token, number_of_runs, cpu_time_limit, cpu_extra_time, wall_time_limit, memory_limit, stack_limit, max_processes_and_or_threads, enable_per_process_and_thread_time_limit, enable_per_process_and_thread_memory_limit, max_file_size, compile_output, exit_code, exit_signal, message, wall_time, compiler_options, command_line_arguments, redirect_stderr_to_stdout, callback_url, additional_files, enable_network, started_at, queued_at, updated_at, queue_host, execution_host)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38)
RETURNING id, source_code, language_id, stdin, expected_output, stdout, status_id, created_at, finished_at, time, memory, stderr, token, number_of_runs, cpu_time_limit, cpu_extra_time, wall_time_limit, memory_limit, stack_limit, max_processes_and_or_threads, enable_per_process_and_thread_time_limit, enable_per_process_and_thread_memory_limit, max_file_size, compile_output, exit_code, exit_signal, message, wall_time, compiler_options, command_line_arguments, redirect_stderr_to_stdout, callback_url, additional_files, enable_network, started_at, queued_at, updated_at, queue_host, execution_host
`

type CreateSubmissionParams struct {
	SourceCode                           pgtype.Text
	LanguageID                           pgtype.Int4
	Stdin                                pgtype.Text
	ExpectedOutput                       pgtype.Text
	Stdout                               pgtype.Text
	StatusID                             pgtype.Int4
	CreatedAt                            pgtype.Timestamp
	FinishedAt                           pgtype.Timestamp
	Time                                 pgtype.Numeric
	Memory                               pgtype.Int4
	Stderr                               pgtype.Text
	Token                                pgtype.Text
	NumberOfRuns                         pgtype.Int4
	CpuTimeLimit                         pgtype.Numeric
	CpuExtraTime                         pgtype.Numeric
	WallTimeLimit                        pgtype.Numeric
	MemoryLimit                          pgtype.Int4
	StackLimit                           pgtype.Int4
	MaxProcessesAndOrThreads             pgtype.Int4
	EnablePerProcessAndThreadTimeLimit   pgtype.Bool
	EnablePerProcessAndThreadMemoryLimit pgtype.Bool
	MaxFileSize                          pgtype.Int4
	CompileOutput                        pgtype.Text
	ExitCode                             pgtype.Int4
	ExitSignal                           pgtype.Int4
	Message                              pgtype.Text
	WallTime                             pgtype.Numeric
	CompilerOptions                      pgtype.Text
	CommandLineArguments                 pgtype.Text
	RedirectStderrToStdout               pgtype.Bool
	CallbackUrl                          pgtype.Text
	AdditionalFiles                      []byte
	EnableNetwork                        pgtype.Bool
	StartedAt                            pgtype.Timestamp
	QueuedAt                             pgtype.Timestamp
	UpdatedAt                            pgtype.Timestamp
	QueueHost                            pgtype.Text
	ExecutionHost                        pgtype.Text
}

// Submissions
func (q *Queries) CreateSubmission(ctx context.Context, arg CreateSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, createSubmission,
		arg.SourceCode,
		arg.LanguageID,
		arg.Stdin,
		arg.ExpectedOutput,
		arg.Stdout,
		arg.StatusID,
		arg.CreatedAt,
		arg.FinishedAt,
		arg.Time,
		arg.Memory,
		arg.Stderr,
		arg.Token,
		arg.NumberOfRuns,
		arg.CpuTimeLimit,
		arg.CpuExtraTime,
		arg.WallTimeLimit,
		arg.MemoryLimit,
		arg.StackLimit,
		arg.MaxProcessesAndOrThreads,
		arg.EnablePerProcessAndThreadTimeLimit,
		arg.EnablePerProcessAndThreadMemoryLimit,
		arg.MaxFileSize,
		arg.CompileOutput,
		arg.ExitCode,
		arg.ExitSignal,
		arg.Message,
		arg.WallTime,
		arg.CompilerOptions,
		arg.CommandLineArguments,
		arg.RedirectStderrToStdout,
		arg.CallbackUrl,
		arg.AdditionalFiles,
		arg.EnableNetwork,
		arg.StartedAt,
		arg.QueuedAt,
		arg.UpdatedAt,
		arg.QueueHost,
		arg.ExecutionHost,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.SourceCode,
		&i.LanguageID,
		&i.Stdin,
		&i.ExpectedOutput,
		&i.Stdout,
		&i.StatusID,
		&i.CreatedAt,
		&i.FinishedAt,
		&i.Time,
		&i.Memory,
		&i.Stderr,
		&i.Token,
		&i.NumberOfRuns,
		&i.CpuTimeLimit,
		&i.CpuExtraTime,
		&i.WallTimeLimit,
		&i.MemoryLimit,
		&i.StackLimit,
		&i.MaxProcessesAndOrThreads,
		&i.EnablePerProcessAndThreadTimeLimit,
		&i.EnablePerProcessAndThreadMemoryLimit,
		&i.MaxFileSize,
		&i.CompileOutput,
		&i.ExitCode,
		&i.ExitSignal,
		&i.Message,
		&i.WallTime,
		&i.CompilerOptions,
		&i.CommandLineArguments,
		&i.RedirectStderrToStdout,
		&i.CallbackUrl,
		&i.AdditionalFiles,
		&i.EnableNetwork,
		&i.StartedAt,
		&i.QueuedAt,
		&i.UpdatedAt,
		&i.QueueHost,
		&i.ExecutionHost,
	)
	return i, err
}

const createTestCase = `-- name: CreateTestCase :one
INSERT INTO test_cases (question_id, question_language_id, input, expected_output, time_constraint, space_constraint)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, question_id, question_language_id, input, expected_output, time_constraint, space_constraint
`

type CreateTestCaseParams struct {
	QuestionID         int32
	QuestionLanguageID int32
	Input              string
	ExpectedOutput     string
	TimeConstraint     pgtype.Float8
	SpaceConstraint    pgtype.Int4
}

// Test Cases
func (q *Queries) CreateTestCase(ctx context.Context, arg CreateTestCaseParams) (TestCase, error) {
	row := q.db.QueryRow(ctx, createTestCase,
		arg.QuestionID,
		arg.QuestionLanguageID,
		arg.Input,
		arg.ExpectedOutput,
		arg.TimeConstraint,
		arg.SpaceConstraint,
	)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.QuestionLanguageID,
		&i.Input,
		&i.ExpectedOutput,
		&i.TimeConstraint,
		&i.SpaceConstraint,
	)
	return i, err
}

const deleteLanguage = `-- name: DeleteLanguage :exec
DELETE FROM languages
WHERE id = $1
`

func (q *Queries) DeleteLanguage(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLanguage, id)
	return err
}

const deletePlayer = `-- name: DeletePlayer :exec
DELETE FROM players
WHERE id = $1
`

func (q *Queries) DeletePlayer(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePlayer, id)
	return err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM questions
WHERE id = $1 AND language_id = $2
`

type DeleteQuestionParams struct {
	ID         int32
	LanguageID int32
}

func (q *Queries) DeleteQuestion(ctx context.Context, arg DeleteQuestionParams) error {
	_, err := q.db.Exec(ctx, deleteQuestion, arg.ID, arg.LanguageID)
	return err
}

const deleteRoom = `-- name: DeleteRoom :exec
DELETE FROM rooms
WHERE id = $1
`

func (q *Queries) DeleteRoom(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRoom, id)
	return err
}

const deleteRoomPlayer = `-- name: DeleteRoomPlayer :exec
DELETE FROM room_players
WHERE room_id = $1 AND player_id = $2
`

type DeleteRoomPlayerParams struct {
	RoomID   int32
	PlayerID int32
}

func (q *Queries) DeleteRoomPlayer(ctx context.Context, arg DeleteRoomPlayerParams) error {
	_, err := q.db.Exec(ctx, deleteRoomPlayer, arg.RoomID, arg.PlayerID)
	return err
}

const deleteSubmission = `-- name: DeleteSubmission :exec
DELETE FROM submissions
WHERE id = $1
`

func (q *Queries) DeleteSubmission(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteSubmission, id)
	return err
}

const deleteTestCase = `-- name: DeleteTestCase :exec
DELETE FROM test_cases
WHERE id = $1
`

func (q *Queries) DeleteTestCase(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTestCase, id)
	return err
}

const getLanguage = `-- name: GetLanguage :one
SELECT id, name, compile_cmd, run_cmd, timeout_second FROM languages
WHERE id = $1
`

func (q *Queries) GetLanguage(ctx context.Context, id int32) (Language, error) {
	row := q.db.QueryRow(ctx, getLanguage, id)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CompileCmd,
		&i.RunCmd,
		&i.TimeoutSecond,
	)
	return i, err
}

const getLanguageByName = `-- name: GetLanguageByName :one
SELECT id, name, compile_cmd, run_cmd, timeout_second FROM languages
where name = $1
`

func (q *Queries) GetLanguageByName(ctx context.Context, name string) (Language, error) {
	row := q.db.QueryRow(ctx, getLanguageByName, name)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CompileCmd,
		&i.RunCmd,
		&i.TimeoutSecond,
	)
	return i, err
}

const getLeaderboardForRoom = `-- name: GetLeaderboardForRoom :many
SELECT p.name, rp.score, rp.place
FROM room_players rp
JOIN players p ON rp.player_id = p.id
WHERE rp.room_id = $1
ORDER BY rp.place
`

type GetLeaderboardForRoomRow struct {
	Name  string
	Score pgtype.Int4
	Place pgtype.Int4
}

func (q *Queries) GetLeaderboardForRoom(ctx context.Context, roomID int32) ([]GetLeaderboardForRoomRow, error) {
	rows, err := q.db.Query(ctx, getLeaderboardForRoom, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaderboardForRoomRow
	for rows.Next() {
		var i GetLeaderboardForRoomRow
		if err := rows.Scan(&i.Name, &i.Score, &i.Place); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayer = `-- name: GetPlayer :one
SELECT id, name, password FROM players
WHERE id = $1
`

func (q *Queries) GetPlayer(ctx context.Context, id int32) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayer, id)
	var i Player
	err := row.Scan(&i.ID, &i.Name, &i.Password)
	return i, err
}

const getPlayerByName = `-- name: GetPlayerByName :one
SELECT id, name, password FROM players
WHERE name = $1
`

func (q *Queries) GetPlayerByName(ctx context.Context, name string) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByName, name)
	var i Player
	err := row.Scan(&i.ID, &i.Name, &i.Password)
	return i, err
}

const getQuestion = `-- name: GetQuestion :one
SELECT id, language_id, template_function, title, description, score, difficulty FROM questions
WHERE id = $1 AND language_id = $2
`

type GetQuestionParams struct {
	ID         int32
	LanguageID int32
}

func (q *Queries) GetQuestion(ctx context.Context, arg GetQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, getQuestion, arg.ID, arg.LanguageID)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.LanguageID,
		&i.TemplateFunction,
		&i.Title,
		&i.Description,
		&i.Score,
		&i.Difficulty,
	)
	return i, err
}

const getRoom = `-- name: GetRoom :one
SELECT id, name, description FROM rooms
WHERE id = $1
`

func (q *Queries) GetRoom(ctx context.Context, id int32) (Room, error) {
	row := q.db.QueryRow(ctx, getRoom, id)
	var i Room
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getRoomPlayer = `-- name: GetRoomPlayer :one
SELECT room_id, player_id, score, place, state FROM room_players
WHERE room_id = $1 AND player_id = $2
`

type GetRoomPlayerParams struct {
	RoomID   int32
	PlayerID int32
}

func (q *Queries) GetRoomPlayer(ctx context.Context, arg GetRoomPlayerParams) (RoomPlayer, error) {
	row := q.db.QueryRow(ctx, getRoomPlayer, arg.RoomID, arg.PlayerID)
	var i RoomPlayer
	err := row.Scan(
		&i.RoomID,
		&i.PlayerID,
		&i.Score,
		&i.Place,
		&i.State,
	)
	return i, err
}

const getRoomPlayers = `-- name: GetRoomPlayers :many
SELECT rp.room_id, rp.player_id, rp.score, rp.place, rp.state
FROM room_players rp
WHERE rp.room_id = $1
ORDER BY rp.score DESC
`

func (q *Queries) GetRoomPlayers(ctx context.Context, roomID int32) ([]RoomPlayer, error) {
	rows, err := q.db.Query(ctx, getRoomPlayers, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoomPlayer
	for rows.Next() {
		var i RoomPlayer
		if err := rows.Scan(
			&i.RoomID,
			&i.PlayerID,
			&i.Score,
			&i.Place,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmission = `-- name: GetSubmission :one
SELECT id, source_code, language_id, stdin, expected_output, stdout, status_id, created_at, finished_at, time, memory, stderr, token, number_of_runs, cpu_time_limit, cpu_extra_time, wall_time_limit, memory_limit, stack_limit, max_processes_and_or_threads, enable_per_process_and_thread_time_limit, enable_per_process_and_thread_memory_limit, max_file_size, compile_output, exit_code, exit_signal, message, wall_time, compiler_options, command_line_arguments, redirect_stderr_to_stdout, callback_url, additional_files, enable_network, started_at, queued_at, updated_at, queue_host, execution_host FROM submissions
WHERE id = $1
`

func (q *Queries) GetSubmission(ctx context.Context, id int32) (Submission, error) {
	row := q.db.QueryRow(ctx, getSubmission, id)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.SourceCode,
		&i.LanguageID,
		&i.Stdin,
		&i.ExpectedOutput,
		&i.Stdout,
		&i.StatusID,
		&i.CreatedAt,
		&i.FinishedAt,
		&i.Time,
		&i.Memory,
		&i.Stderr,
		&i.Token,
		&i.NumberOfRuns,
		&i.CpuTimeLimit,
		&i.CpuExtraTime,
		&i.WallTimeLimit,
		&i.MemoryLimit,
		&i.StackLimit,
		&i.MaxProcessesAndOrThreads,
		&i.EnablePerProcessAndThreadTimeLimit,
		&i.EnablePerProcessAndThreadMemoryLimit,
		&i.MaxFileSize,
		&i.CompileOutput,
		&i.ExitCode,
		&i.ExitSignal,
		&i.Message,
		&i.WallTime,
		&i.CompilerOptions,
		&i.CommandLineArguments,
		&i.RedirectStderrToStdout,
		&i.CallbackUrl,
		&i.AdditionalFiles,
		&i.EnableNetwork,
		&i.StartedAt,
		&i.QueuedAt,
		&i.UpdatedAt,
		&i.QueueHost,
		&i.ExecutionHost,
	)
	return i, err
}

const getTestCase = `-- name: GetTestCase :one
SELECT id, question_id, question_language_id, input, expected_output, time_constraint, space_constraint FROM test_cases
WHERE id = $1
`

func (q *Queries) GetTestCase(ctx context.Context, id int32) (TestCase, error) {
	row := q.db.QueryRow(ctx, getTestCase, id)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.QuestionLanguageID,
		&i.Input,
		&i.ExpectedOutput,
		&i.TimeConstraint,
		&i.SpaceConstraint,
	)
	return i, err
}

const listLanguages = `-- name: ListLanguages :many
SELECT id, name, compile_cmd, run_cmd, timeout_second FROM languages
ORDER BY id
`

func (q *Queries) ListLanguages(ctx context.Context) ([]Language, error) {
	rows, err := q.db.Query(ctx, listLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CompileCmd,
			&i.RunCmd,
			&i.TimeoutSecond,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayers = `-- name: ListPlayers :many
SELECT id, name, password FROM players
ORDER BY id
`

func (q *Queries) ListPlayers(ctx context.Context) ([]Player, error) {
	rows, err := q.db.Query(ctx, listPlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(&i.ID, &i.Name, &i.Password); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayersInRoom = `-- name: ListPlayersInRoom :many
SELECT p.id, p.name, p.password FROM players p
JOIN room_players rp ON p.id = rp.player_id
WHERE rp.room_id = $1
ORDER BY rp.place
`

func (q *Queries) ListPlayersInRoom(ctx context.Context, roomID int32) ([]Player, error) {
	rows, err := q.db.Query(ctx, listPlayersInRoom, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(&i.ID, &i.Name, &i.Password); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestions = `-- name: ListQuestions :many
SELECT id, language_id, template_function, title, description, score, difficulty FROM questions
ORDER BY id, language_id
`

func (q *Queries) ListQuestions(ctx context.Context) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Question
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.TemplateFunction,
			&i.Title,
			&i.Description,
			&i.Score,
			&i.Difficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByLanguage = `-- name: ListQuestionsByLanguage :many
SELECT id, language_id, template_function, title, description, score, difficulty FROM questions
WHERE language_id = $1
ORDER BY id
`

func (q *Queries) ListQuestionsByLanguage(ctx context.Context, languageID int32) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByLanguage, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Question
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.TemplateFunction,
			&i.Title,
			&i.Description,
			&i.Score,
			&i.Difficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRooms = `-- name: ListRooms :many
SELECT id, name, description FROM rooms
ORDER BY id
`

func (q *Queries) ListRooms(ctx context.Context) ([]Room, error) {
	rows, err := q.db.Query(ctx, listRooms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Room
	for rows.Next() {
		var i Room
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubmissions = `-- name: ListSubmissions :many
SELECT id, source_code, language_id, stdin, expected_output, stdout, status_id, created_at, finished_at, time, memory, stderr, token, number_of_runs, cpu_time_limit, cpu_extra_time, wall_time_limit, memory_limit, stack_limit, max_processes_and_or_threads, enable_per_process_and_thread_time_limit, enable_per_process_and_thread_memory_limit, max_file_size, compile_output, exit_code, exit_signal, message, wall_time, compiler_options, command_line_arguments, redirect_stderr_to_stdout, callback_url, additional_files, enable_network, started_at, queued_at, updated_at, queue_host, execution_host FROM submissions
ORDER BY id
`

func (q *Queries) ListSubmissions(ctx context.Context) ([]Submission, error) {
	rows, err := q.db.Query(ctx, listSubmissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Submission
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.ID,
			&i.SourceCode,
			&i.LanguageID,
			&i.Stdin,
			&i.ExpectedOutput,
			&i.Stdout,
			&i.StatusID,
			&i.CreatedAt,
			&i.FinishedAt,
			&i.Time,
			&i.Memory,
			&i.Stderr,
			&i.Token,
			&i.NumberOfRuns,
			&i.CpuTimeLimit,
			&i.CpuExtraTime,
			&i.WallTimeLimit,
			&i.MemoryLimit,
			&i.StackLimit,
			&i.MaxProcessesAndOrThreads,
			&i.EnablePerProcessAndThreadTimeLimit,
			&i.EnablePerProcessAndThreadMemoryLimit,
			&i.MaxFileSize,
			&i.CompileOutput,
			&i.ExitCode,
			&i.ExitSignal,
			&i.Message,
			&i.WallTime,
			&i.CompilerOptions,
			&i.CommandLineArguments,
			&i.RedirectStderrToStdout,
			&i.CallbackUrl,
			&i.AdditionalFiles,
			&i.EnableNetwork,
			&i.StartedAt,
			&i.QueuedAt,
			&i.UpdatedAt,
			&i.QueueHost,
			&i.ExecutionHost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestCasesForQuestion = `-- name: ListTestCasesForQuestion :many
SELECT id, question_id, question_language_id, input, expected_output, time_constraint, space_constraint FROM test_cases
WHERE question_id = $1 AND question_language_id = $2
ORDER BY id
`

type ListTestCasesForQuestionParams struct {
	QuestionID         int32
	QuestionLanguageID int32
}

func (q *Queries) ListTestCasesForQuestion(ctx context.Context, arg ListTestCasesForQuestionParams) ([]TestCase, error) {
	rows, err := q.db.Query(ctx, listTestCasesForQuestion, arg.QuestionID, arg.QuestionLanguageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.QuestionLanguageID,
			&i.Input,
			&i.ExpectedOutput,
			&i.TimeConstraint,
			&i.SpaceConstraint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLanguage = `-- name: UpdateLanguage :one
UPDATE languages
SET name = $2, compile_cmd = $3, run_cmd = $4, timeout_second = $5
WHERE id = $1
RETURNING id, name, compile_cmd, run_cmd, timeout_second
`

type UpdateLanguageParams struct {
	ID            int32
	Name          string
	CompileCmd    pgtype.Text
	RunCmd        pgtype.Text
	TimeoutSecond pgtype.Float8
}

func (q *Queries) UpdateLanguage(ctx context.Context, arg UpdateLanguageParams) (Language, error) {
	row := q.db.QueryRow(ctx, updateLanguage,
		arg.ID,
		arg.Name,
		arg.CompileCmd,
		arg.RunCmd,
		arg.TimeoutSecond,
	)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CompileCmd,
		&i.RunCmd,
		&i.TimeoutSecond,
	)
	return i, err
}

const updatePlayer = `-- name: UpdatePlayer :one
UPDATE players
SET name = $2, password = $3
WHERE id = $1
RETURNING id, name, password
`

type UpdatePlayerParams struct {
	ID       int32
	Name     string
	Password string
}

func (q *Queries) UpdatePlayer(ctx context.Context, arg UpdatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayer, arg.ID, arg.Name, arg.Password)
	var i Player
	err := row.Scan(&i.ID, &i.Name, &i.Password)
	return i, err
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE questions
SET template_function = $3, title = $4, description = $5, score = $6, difficulty = $7
WHERE id = $1 AND language_id = $2
RETURNING id, language_id, template_function, title, description, score, difficulty
`

type UpdateQuestionParams struct {
	ID               int32
	LanguageID       int32
	TemplateFunction pgtype.Text
	Title            string
	Description      pgtype.Text
	Score            int32
	Difficulty       int32
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, updateQuestion,
		arg.ID,
		arg.LanguageID,
		arg.TemplateFunction,
		arg.Title,
		arg.Description,
		arg.Score,
		arg.Difficulty,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.LanguageID,
		&i.TemplateFunction,
		&i.Title,
		&i.Description,
		&i.Score,
		&i.Difficulty,
	)
	return i, err
}

const updateRoom = `-- name: UpdateRoom :one
UPDATE rooms
SET name = $2, description = $3
WHERE id = $1
RETURNING id, name, description
`

type UpdateRoomParams struct {
	ID          int32
	Name        string
	Description pgtype.Text
}

func (q *Queries) UpdateRoom(ctx context.Context, arg UpdateRoomParams) (Room, error) {
	row := q.db.QueryRow(ctx, updateRoom, arg.ID, arg.Name, arg.Description)
	var i Room
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const updateRoomPlayerRanks = `-- name: UpdateRoomPlayerRanks :exec
WITH ranked_players AS (
  SELECT
    player_id,
    RANK() OVER (ORDER BY score DESC) as new_place
  FROM room_players
  WHERE room_id = $1
)
UPDATE room_players rp
SET place = rp_ranked.new_place
FROM ranked_players rp_ranked
WHERE rp.room_id = $1 AND rp.player_id = rp_ranked.player_id
`

func (q *Queries) UpdateRoomPlayerRanks(ctx context.Context, roomID int32) error {
	_, err := q.db.Exec(ctx, updateRoomPlayerRanks, roomID)
	return err
}

const updateRoomPlayerScore = `-- name: UpdateRoomPlayerScore :one
UPDATE room_players
SET score = $3, place = $4
WHERE room_id = $1 AND player_id = $2
RETURNING room_id, player_id, score, place, state
`

type UpdateRoomPlayerScoreParams struct {
	RoomID   int32
	PlayerID int32
	Score    pgtype.Int4
	Place    pgtype.Int4
}

func (q *Queries) UpdateRoomPlayerScore(ctx context.Context, arg UpdateRoomPlayerScoreParams) (RoomPlayer, error) {
	row := q.db.QueryRow(ctx, updateRoomPlayerScore,
		arg.RoomID,
		arg.PlayerID,
		arg.Score,
		arg.Place,
	)
	var i RoomPlayer
	err := row.Scan(
		&i.RoomID,
		&i.PlayerID,
		&i.Score,
		&i.Place,
		&i.State,
	)
	return i, err
}

const updateSubmission = `-- name: UpdateSubmission :one
UPDATE submissions
SET source_code = $2, language_id = $3, stdin = $4, expected_output = $5, stdout = $6, status_id = $7, created_at = $8, finished_at = $9, time = $10, memory = $11, stderr = $12, token = $13, number_of_runs = $14, cpu_time_limit = $15, cpu_extra_time = $16, wall_time_limit = $17, memory_limit = $18, stack_limit = $19, max_processes_and_or_threads = $20, enable_per_process_and_thread_time_limit = $21, enable_per_process_and_thread_memory_limit = $22, max_file_size = $23, compile_output = $24, exit_code = $25, exit_signal = $26, message = $27, wall_time = $28, compiler_options = $29, command_line_arguments = $30, redirect_stderr_to_stdout = $31, callback_url = $32, additional_files = $33, enable_network = $34, started_at = $35, queued_at = $36, updated_at = $37, queue_host = $38, execution_host = $39
WHERE id = $1
RETURNING id, source_code, language_id, stdin, expected_output, stdout, status_id, created_at, finished_at, time, memory, stderr, token, number_of_runs, cpu_time_limit, cpu_extra_time, wall_time_limit, memory_limit, stack_limit, max_processes_and_or_threads, enable_per_process_and_thread_time_limit, enable_per_process_and_thread_memory_limit, max_file_size, compile_output, exit_code, exit_signal, message, wall_time, compiler_options, command_line_arguments, redirect_stderr_to_stdout, callback_url, additional_files, enable_network, started_at, queued_at, updated_at, queue_host, execution_host
`

type UpdateSubmissionParams struct {
	ID                                   int32
	SourceCode                           pgtype.Text
	LanguageID                           pgtype.Int4
	Stdin                                pgtype.Text
	ExpectedOutput                       pgtype.Text
	Stdout                               pgtype.Text
	StatusID                             pgtype.Int4
	CreatedAt                            pgtype.Timestamp
	FinishedAt                           pgtype.Timestamp
	Time                                 pgtype.Numeric
	Memory                               pgtype.Int4
	Stderr                               pgtype.Text
	Token                                pgtype.Text
	NumberOfRuns                         pgtype.Int4
	CpuTimeLimit                         pgtype.Numeric
	CpuExtraTime                         pgtype.Numeric
	WallTimeLimit                        pgtype.Numeric
	MemoryLimit                          pgtype.Int4
	StackLimit                           pgtype.Int4
	MaxProcessesAndOrThreads             pgtype.Int4
	EnablePerProcessAndThreadTimeLimit   pgtype.Bool
	EnablePerProcessAndThreadMemoryLimit pgtype.Bool
	MaxFileSize                          pgtype.Int4
	CompileOutput                        pgtype.Text
	ExitCode                             pgtype.Int4
	ExitSignal                           pgtype.Int4
	Message                              pgtype.Text
	WallTime                             pgtype.Numeric
	CompilerOptions                      pgtype.Text
	CommandLineArguments                 pgtype.Text
	RedirectStderrToStdout               pgtype.Bool
	CallbackUrl                          pgtype.Text
	AdditionalFiles                      []byte
	EnableNetwork                        pgtype.Bool
	StartedAt                            pgtype.Timestamp
	QueuedAt                             pgtype.Timestamp
	UpdatedAt                            pgtype.Timestamp
	QueueHost                            pgtype.Text
	ExecutionHost                        pgtype.Text
}

func (q *Queries) UpdateSubmission(ctx context.Context, arg UpdateSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, updateSubmission,
		arg.ID,
		arg.SourceCode,
		arg.LanguageID,
		arg.Stdin,
		arg.ExpectedOutput,
		arg.Stdout,
		arg.StatusID,
		arg.CreatedAt,
		arg.FinishedAt,
		arg.Time,
		arg.Memory,
		arg.Stderr,
		arg.Token,
		arg.NumberOfRuns,
		arg.CpuTimeLimit,
		arg.CpuExtraTime,
		arg.WallTimeLimit,
		arg.MemoryLimit,
		arg.StackLimit,
		arg.MaxProcessesAndOrThreads,
		arg.EnablePerProcessAndThreadTimeLimit,
		arg.EnablePerProcessAndThreadMemoryLimit,
		arg.MaxFileSize,
		arg.CompileOutput,
		arg.ExitCode,
		arg.ExitSignal,
		arg.Message,
		arg.WallTime,
		arg.CompilerOptions,
		arg.CommandLineArguments,
		arg.RedirectStderrToStdout,
		arg.CallbackUrl,
		arg.AdditionalFiles,
		arg.EnableNetwork,
		arg.StartedAt,
		arg.QueuedAt,
		arg.UpdatedAt,
		arg.QueueHost,
		arg.ExecutionHost,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.SourceCode,
		&i.LanguageID,
		&i.Stdin,
		&i.ExpectedOutput,
		&i.Stdout,
		&i.StatusID,
		&i.CreatedAt,
		&i.FinishedAt,
		&i.Time,
		&i.Memory,
		&i.Stderr,
		&i.Token,
		&i.NumberOfRuns,
		&i.CpuTimeLimit,
		&i.CpuExtraTime,
		&i.WallTimeLimit,
		&i.MemoryLimit,
		&i.StackLimit,
		&i.MaxProcessesAndOrThreads,
		&i.EnablePerProcessAndThreadTimeLimit,
		&i.EnablePerProcessAndThreadMemoryLimit,
		&i.MaxFileSize,
		&i.CompileOutput,
		&i.ExitCode,
		&i.ExitSignal,
		&i.Message,
		&i.WallTime,
		&i.CompilerOptions,
		&i.CommandLineArguments,
		&i.RedirectStderrToStdout,
		&i.CallbackUrl,
		&i.AdditionalFiles,
		&i.EnableNetwork,
		&i.StartedAt,
		&i.QueuedAt,
		&i.UpdatedAt,
		&i.QueueHost,
		&i.ExecutionHost,
	)
	return i, err
}

const updateTestCase = `-- name: UpdateTestCase :one
UPDATE test_cases
SET input = $2, expected_output = $3, time_constraint = $4, space_constraint = $5
WHERE id = $1
RETURNING id, question_id, question_language_id, input, expected_output, time_constraint, space_constraint
`

type UpdateTestCaseParams struct {
	ID              int32
	Input           string
	ExpectedOutput  string
	TimeConstraint  pgtype.Float8
	SpaceConstraint pgtype.Int4
}

func (q *Queries) UpdateTestCase(ctx context.Context, arg UpdateTestCaseParams) (TestCase, error) {
	row := q.db.QueryRow(ctx, updateTestCase,
		arg.ID,
		arg.Input,
		arg.ExpectedOutput,
		arg.TimeConstraint,
		arg.SpaceConstraint,
	)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.QuestionLanguageID,
		&i.Input,
		&i.ExpectedOutput,
		&i.TimeConstraint,
		&i.SpaceConstraint,
	)
	return i, err
}
